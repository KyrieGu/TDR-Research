import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JFrame;
import javax.swing.JLabel;
import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;


import java.text.ParseException;
import java.text.SimpleDateFormat;


public class CreateReadingBehavior {
	// socket for connection to SISServer
	private static Socket universal;
	// message writer
	private static int port = 53217;
	private static MsgEncoder encoder;
	// message reader
	private static MsgDecoder decoder;
	// scope of this component
	private static final String SCOPE = "SIS.Ren";
	// name of this component
    private static final String NAME = "ReadingBehavior";
	// messages types that can be handled by this component
	
	private static final List<String> TYPES = new ArrayList<String>(
			Arrays.asList(new String[] { "Setting", "Confirm" }));
			
	private static final String incomingMessages = "IN\tConfirm|Setting:Kill";
	private static final String outgoingMessages = "OUT\t Reading|Alert";

	private static int refreshRate = 900000, max = 140, min = 90;
	private static Date startDate = new Date(), endDate = new Date();

	private static Timer timer = new Timer();

	// shared by all kinds of records that can be generated by this component
	private static KeyValueList record = new KeyValueList();
	// shared by all kinds of alerts that can be generated by this component
	private static KeyValueList alert = new KeyValueList();

	private static ReadingBehaviorReading reading = new ReadingBehaviorReading();

	private static HashMap<String, String> params = new HashMap<>();
	/*
	 * Main program
	 */
	public static void main(String[] args) {
		while (true) {
			try {
				// try to establish a connection to SISServer
				universal = connect();

				// bind the message reader to inputstream of the socket
				decoder = new MsgDecoder(universal.getInputStream());
				// bind the message writer to outputstream of the socket
				encoder = new MsgEncoder(universal.getOutputStream());

				/*
				 * construct a Connect message to establish the connection
				 */
				KeyValueList conn = new KeyValueList();
				conn.putPair("Scope", SCOPE);
				conn.putPair("MessageType", "Connect");
				conn.putPair("IncomingMessages", incomingMessages);
                conn.putPair("OutgoingMessages", outgoingMessages);
				conn.putPair("Role", "Basic");
				conn.putPair("Name", NAME);
				encoder.sendMsg(conn);

				initRecord();

				// componentTask();

				// KeyValueList for inward messages, see KeyValueList for
				// details
				KeyValueList kvList;

				while (true) {
					// attempt to read and decode a message, see MsgDecoder for
					// details
					kvList = decoder.getMsg();

					// process that message
					ProcessMsg(kvList);
				}

			} catch (Exception e) {
				// if anything goes wrong, try to re-establish the connection
				e.printStackTrace();
				try {
					// wait for 1 second to retry
					Thread.sleep(1000);
				} catch (InterruptedException e2) {
				}
				System.out.println("Try to reconnect");
				try {
					universal = connect();
				} catch (IOException e1) {
				}
			}
		}
	}

	/*
	 * used for connect(reconnect) to SISServer
	 */
	private static Socket connect() throws IOException {
		Socket socket = new Socket("127.0.0.1", 53217);
		return socket;
	}

	private static void initRecord() {
		record.putPair("Scope", SCOPE);
		record.putPair("MessageType", "Reading");
		record.putPair("Sender", NAME);
		record.putPair("Broadcast", "True");
		record.putPair("Direction", "Up");

		// Receiver may be different for each message, so it doesn't make sense
		// to set here
		// record.putPair("Receiver", "");

		alert.putPair("Scope", SCOPE);
		alert.putPair("MessageType", "Alert");
		alert.putPair("Sender", NAME);
		alert.putPair("Purpose", "ReadingBehaviorAlert");
		alert.putPair("Broadcast", "True");
		alert.putPair("Direction", "Up");

		// Receiver may be different for each message, so it doesn't make sense
		// to set here
		// alert.putPair("Receiver", "");
	}

	private static void componentTask() {
		try {
			fetch();
			//record.putPair("AirTemperature", reading.temperature + "");
			//record.putPair("Fertilizer", reading.fertilizer + "");
			//record.putPair("Light", reading.sunshine + "");
			//record.putPair("Moisture", reading.moisture + "");
			//encoder.sendMsg(record);

			
			alert.putPair("GazeX", reading.x + "");
			alert.putPair("GazeY", reading.y + "");
			alert.putPair("TimeStamp", reading.t + "");
			alert.putPair("GazeXArray", reading.xArray.toString() + "");
			alert.putPair("GazeYArray", reading.yArray.toString() + "");
			alert.putPair("TimeStampArray", reading.tArray.toString() + "");
			reading.xArray.setLength(0);
			reading.yArray.setLength(0);
			reading.tArray.setLength(0);
			reading.xArray.append("0");
			reading.yArray.append("0");
			reading.tArray.append("0");
			
			
			encoder.sendMsg(alert);
			
			
			
			/*alert.putPair("Systolic", reading.systolic + "");
			alert.putPair("Diastolic", reading.diastolic + "");
			alert.putPair("Pulse", reading.pulse + "");
			alert.putPair("Date", reading.date + "");
			// 140/90
			if (reading.systolic > max || reading.diastolic > min) {
				encoder.sendMsg(alert);
			}*/

		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

	private static void ProcessMsg(KeyValueList kvList) throws Exception {

		String scope = kvList.getValue("Scope");
		if (!SCOPE.startsWith(scope)) {
			return;
		}

		String messageType = kvList.getValue("MessageType");
		if (!TYPES.contains(messageType)) {
			return;
		}

		String sender = kvList.getValue("Sender");

		String receiver = kvList.getValue("Receiver");

		String purpose = kvList.getValue("Purpose");

		switch (messageType) {
		case "Confirm":
			System.out.println("Connect to SISServer successful.");
			break;
		case "Setting":
			if (receiver.equals(NAME)) {

				//System.out.println(kvList);
				// System.out.println("Message from " + sender);
				// System.out.println("Message type: " + messageType);
				// System.out.println("Message Purpose: " + purpose);
				switch (purpose) {

				case "Activate":
					String rRate = kvList.getValue("RefreshRate");
					String sDate = kvList.getValue("StartDate");
					String eDate = kvList.getValue("EndDate");
					String maxx = kvList.getValue("Max");
					String minn = kvList.getValue("Min");

					if (rRate != null && !rRate.equals("")) {

						refreshRate = Integer.parseInt(rRate);
					}

					if (sDate != null && !sDate.equals("") && eDate != null
							&& !eDate.equals("")) {
						startDate.setTime(Long.parseLong(sDate));
						endDate.setTime(Long.parseLong(eDate));
					}

					if (maxx != null && !maxx.equals("") && minn != null
							&& !minn.equals("")) {
						max = Integer.parseInt(maxx);
						min = Integer.parseInt(minn);
					}
					try {
						timer.cancel();
						timer = new Timer();
					} catch (Exception e) {
						// TODO: handle exception
					}
					timer.schedule(new TimerTask() {

						@Override
						public void run() {
							// TODO Auto-generated method stub
							if (System.currentTimeMillis() - endDate.getTime() > 0) {
								cancel();
							} else {
								componentTask();
							}
						}
					}, startDate, refreshRate);
					System.out.println("Algorithm Activated");
					break;

				// case "AdjustRefreshRate":
				// String rRate = kvList.getValue("RefreshRate");
				// if (rRate != null && !rRate.equals("")) {
				// timer.cancel();
				// timer.purge();
				// refreshRate = Integer.parseInt(rRate);
				// timer.schedule(new TimerTask() {
				//
				// @Override
				// public void run() {
				// // TODO Auto-generated method stub
				// componentTask();
				// }
				// }, startDate, refreshRate);
				// }
				//
				// break;
				// case "AdjustDateRange":
				// String sDate = kvList.getValue("StartDate");
				// String eDate = kvList.getValue("EndDate");
				// if (sDate != null && !sDate.equals("") && eDate != null
				// && !eDate.equals("")) {
				// timer.cancel();
				// timer.purge();
				// startDate.setTime(Long.parseLong(sDate));
				// endDate.setTime(Long.parseLong(eDate));
				// timer.schedule(new TimerTask() {
				//
				// @Override
				// public void run() {
				// // TODO Auto-generated method stub
				// componentTask();
				// }
				// }, startDate, refreshRate);
				// }
				//
				// break;
				// case "AdjustThreshold":
				// String maxx = kvList.getValue("Max");
				// String minn = kvList.getValue("Min");
				// if (maxx != null && !maxx.equals("") && minn != null
				// && !minn.equals("")) {
				// timer.cancel();
				// timer.purge();
				// max = Integer.parseInt(maxx);
				// min = Integer.parseInt(minn);
				// timer.schedule(new TimerTask() {
				//
				// @Override
				// public void run() {
				// // TODO Auto-generated method stub
				// componentTask();
				// }
				// }, startDate, refreshRate);
				// }
				// break;

				case "Kill":
					try {
						timer.cancel();
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.exit(0);
					break;
				// case "Activate":
				// try {
				// timer.cancel();
				// timer = new Timer();
				// } catch (Exception e) {
				// // TODO: handle exception
				// }
				// timer.schedule(new TimerTask() {
				//
				// @Override
				// public void run() {
				// // TODO Auto-generated method stub
				// if (System.currentTimeMillis() - endDate.getTime() > 0) {
				// cancel();
				// } else {
				// componentTask();
				// }
				// }
				// }, startDate, refreshRate);
				// System.out.println("Algorithm Activated");
				// break;
				case "Deactivate":
					try {
						timer.cancel();
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.out.println("Algorithm Deactivated");
					break;
				}
			}
			break;
		}
	}
	
	private static void fetch() throws Exception {
		System.out.println("in fetch");
		Process process = null;
		try{
			System.out.println("in try of fetch");
	    	process = Runtime.getRuntime().exec("adb logcat -c");
	    	process = null;
	    	ArrayList<String> commandLine = new ArrayList<String>();
			commandLine.clear();   
	    	commandLine.add("adb");
	    	commandLine.add("logcat");
	    	commandLine.add("ReadingBehaviorData:I");
	    	commandLine.add("*:S");
			process = Runtime.getRuntime().exec(commandLine.toArray(new String[commandLine.size()])); 
	    	BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()), 1024); 
	    	String line = "";
	    	line = bufferedReader.readLine();
	    	while ( line!= null){
	    			process(line);
	    			String temp = bufferedReader.readLine();
	    			line=temp;
	    	}
	    } catch(Exception ex){
			System.out.println("in catch of fetch");
	    	//System.out.println(ex.toString());
	    	ex.printStackTrace();
	    	//System.out.println("error in Collector_logcat\n");
	    }
//		params.put("grant_type", "password");
//		params.put("username", "weg21@pitt.edu");
//		params.put("password", "se2015");
//		params.put("client_id", "weg21@pitt.edu");
//		params.put("client_secret", "qbnJTlt34DBN83kgf6iwDejsJLhqKcePLBnUqZ3TbMNvZidn");
//
//		try {
//			String urlForAccTok = "https://apiflowerpower.parrot.com/user/v1/authenticate";
//			StringBuilder builder = new StringBuilder();
//			builder.append(urlForAccTok + "?");
//			for (Map.Entry<String, String> entry : params.entrySet()) {
//				builder.append(entry.getKey() + "=" + entry.getValue() + "&");
//			}
//
//			builder.deleteCharAt(builder.length() - 1);
//			String access_token = getAccessToken(getJSON(builder.toString()));
//			System.out.println(access_token);
//
//			String urlForData = "https://apiflowerpower.parrot.com/sensor_data/v4/garden_locations_status";
//
//			JSONObject obj = getJSONWithAccessToken(urlForData, access_token);
//			
//			
//			
//			System.out.println(obj);
//			System.out.println(obj.get("locations"));
//			updateData(obj);
//			
//
//		} catch (IOException | JSONException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
	}
	
	public static void process(String log){
		if(log == null) return;	
		if (log.contains("ReadingBehaviorData")) {
			StringTokenizer st = new StringTokenizer(log, " ");
			st.nextToken();
			st.nextToken();
			st.nextToken();
			st.nextToken();
			st.nextToken();
			st.nextToken();
			if(st.hasMoreTokens()){
				String s = st.nextToken();
				s = s.trim();
				StringTokenizer st2 = new StringTokenizer(s, ",");
				double valuex = Double.parseDouble(st2.nextToken());
				double valuey = Double.parseDouble(st2.nextToken());
				long timestamp = Long.parseLong(st2.nextToken());
				System.out.println("GazeX: "+valuex);
				System.out.println("GazeY: "+valuey);
				System.out.println("Time: "+timestamp);
				reading.x = valuex;
				reading.y = valuey;
				reading.t = timestamp;
				reading.xArray.append(","+valuex);
				reading.yArray.append(","+valuey);
				reading.tArray.append(","+timestamp);
				
			}
		}
	}
	
//	private static String getAccessToken(JSONObject root) throws JSONException {
//		return root.get("access_token").toString();
//	}
//	
//	private static void updateData(JSONObject obj) throws JSONException,ParseException{
//		JSONArray ary=(JSONArray) obj.get("locations");
//		JSONObject objData=(JSONObject) ary.get(0);
//		
//		JSONObject temp= (JSONObject) objData.get("air_temperature");
//		JSONObject tempVal =(JSONObject) temp.get("gauge_values");
//		
//		JSONObject fert= (JSONObject) objData.get("fertilizer");
//		JSONObject fertVal =(JSONObject) fert.get("gauge_values");
//		
//		JSONObject ligh= (JSONObject) objData.get("light");
//		JSONObject lighVal =(JSONObject) ligh.get("gauge_values");
//		
//		JSONObject mois= (JSONObject) objData.get("soil_moisture");
//		JSONObject moisVal =(JSONObject) mois.get("gauge_values");
//		//StringBuilder builder = new StringBuilder();
//		
//		JSONArray ary0=(JSONArray) obj.get("sensors");
//		JSONObject objData0=(JSONObject) ary0.get(0);
//		String date= (String) objData0.get("last_upload_datetime_utc");
//
//		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
//		Date date11 = df.parse(date);
//		long dateNew = date11.getTime();
//		reading.preDateFP=reading.dateFP;
//		reading.dateFP = dateNew;
//		
//		reading.temperature = tempVal.getDouble("current_value");
//		reading.fertilizer = fertVal.getDouble("current_value");
//		reading.sunshine = lighVal.getDouble("current_value");
//		reading.moisture = moisVal.getDouble("current_value");
//		
//
//		
//		/*builder.append("Sensor Data for Tomato plant: \n");
//		builder.append("Air_temperature: "+tempVal.get("current_value")+"\n");
//		builder.append("Fertilizer: "+fertVal.get("current_value")+"\n");
//		builder.append("Light: "+lighVal.get("current_value")+"\n");
//		builder.append("Moisture: "+moisVal.get("current_value"));
//		
//		
//		return builder.toString();*/
//	}
//
//	private static JSONObject getJSONWithAccessToken(String urlStr, String accTok) throws IOException {
//		URL url = new URL(urlStr);
//
//		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
//		conn.setRequestProperty("Authorization", "Bearer " + accTok);
//		try (InputStream is = conn.getInputStream()) {
//			JSONTokener tokener = new JSONTokener(is);
//
//			JSONObject root = new JSONObject(tokener);
//			return root;
//		} catch (Exception e) {
//			// TODO: handle exception
//			return null;
//		}
//	}
//
//	private static JSONObject getJSON(String urlStr) throws IOException {
//		URL url = new URL(urlStr);
//		try (InputStream is = url.openStream()) {
//			JSONTokener tokener = new JSONTokener(is);
//
//			JSONObject root = new JSONObject(tokener);
//			return root;
//		} catch (Exception e) {
//			// TODO: handle exception
//			return null;
//		}
//	}
	
}

class ReadingBehaviorReading {
	StringBuilder xArray = new StringBuilder("0");
	StringBuilder yArray = new StringBuilder("0");
	StringBuilder tArray = new StringBuilder("0");
	double x;
	double y;
	long t;
}
