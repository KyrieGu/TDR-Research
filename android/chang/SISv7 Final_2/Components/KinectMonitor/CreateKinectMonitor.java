import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentLinkedQueue;

public class CreateKinectMonitor {
	// socket for connection to SISServer
	static Socket universal;
	private static int port = 53217;
	// message writer
	static MsgEncoder encoder;
	// message reader
	static MsgDecoder decoder;

	// scope of this component
	private static final String SCOPE = "SIS.Ren";
	// name of this component
    private static final String NAME = "KinectMonitor";
	// messages types that can be handled by this component
	private static final List<String> TYPES = new ArrayList<String>(
			Arrays.asList(new String[] { "Setting", "Confirm" }));

	private static int refreshRate = 500, max, min;
	private static Date startDate = new Date(), endDate = new Date();

	private static Timer timer = new Timer();

	// shared by all kinds of records that can be generated by this component
	private static KeyValueList record = new KeyValueList();
	// shared by all kinds of alerts that can be generated by this component
	private static KeyValueList alert = new KeyValueList();

	private static KinectReading reading = new KinectReading();

	static ConcurrentLinkedQueue<Queue<Vec>> queue = new ConcurrentLinkedQueue<Queue<Vec>>();

	static int count = 0;

	/*
	 * Main program
	 */
	public static void main(String[] args) {
		while (true) {
			try {
				// try to establish a connection to SISServer
				universal = connect();

				// bind the message reader to inputstream of the socket
				decoder = new MsgDecoder(universal.getInputStream());
				// bind the message writer to outputstream of the socket
				encoder = new MsgEncoder(universal.getOutputStream());

				/*
				 * construct a message 23 to establish the connection
				 */
				KeyValueList conn = new KeyValueList();
				conn.putPair("Scope", SCOPE);
				conn.putPair("MessageType", "Connect");
				conn.putPair("Role", "Basic");
				conn.putPair("Name", NAME);
				encoder.sendMsg(conn);

				initRecord();

				// KeyValueList for inward messages, see KeyValueList for
				// details
				KeyValueList kvList;

				while (true) {
					// attempt to read and decode a message, see MsgDecoder for
					// details
					kvList = decoder.getMsg();

					// process that message
					ProcessMsg(kvList);
				}

			} catch (Exception e) {
				// if anything goes wrong, try to re-establish the connection
				try {
					// wait for 1 second to retry
					Thread.sleep(1000);
				} catch (InterruptedException e2) {
				}
				
				System.out.println("Try to reconnect");
				try {
					universal = connect();
				} catch (IOException e1) {
				}
			}
		}
	}

	/*
	 * used for connect(reconnect) to SISServer
	 */
	static Socket connect() throws IOException {
		Socket socket = new Socket("127.0.0.1", port);
		return socket;
	}

	private static void initRecord() {
		record.putPair("Scope", SCOPE);
		record.putPair("MessageType", "Reading");
		record.putPair("Sender", NAME);

		// Receiver may be different for each message, so it doesn't make sense
		// to set here
		// record.putPair("Receiver", "");

		alert.putPair("Scope", SCOPE);
		alert.putPair("MessageType", "Alert");
		alert.putPair("Sender", NAME);

		// Receiver may be different for each message, so it doesn't make sense
		// to set here
		// alert.putPair("Receiver", "");
	}

	private static void componentTask() {
		try {

			// record.putPair("Systolic", reading.systolic + "");
			// record.putPair("Diastolic", reading.diastolic + "");
			// record.putPair("Pulse", reading.pulse + "");

			record.putPair("KinectData", reading.getCoordinates());
			record.putPair("Date", reading.date + "");
			encoder.sendMsg(record);
			
			alert.putPair("KinectData", reading.getCoordinates());

			// alert.putPair("Systolic", reading.systolic + "");
			// alert.putPair("Diastolic", reading.diastolic + "");
			// alert.putPair("Pulse", reading.pulse + "");
			// alert.putPair("Date", reading.date + "");
			// if (reading.systolic > max || reading.diastolic > min) {
			// encoder.sendMsg(alert);
			// }

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	static boolean fall() {
		if (count < 5) {
			return false;
		} else {
			Queue<Vec> sum = queue.poll();
			Queue<Vec> s1 = queue.poll();
			Queue<Vec> s2 = queue.poll();
			Queue<Vec> s3 = queue.poll();
			Queue<Vec> s4 = queue.poll();
			int total = 0;
			if (s4 != null) {
				for (int i = 0; i < sum.size(); i++) {
					total += sum.poll().subtract(s4.poll());
				}
			} else if (s3 != null) {
				for (int i = 0; i < sum.size(); i++) {
					total += sum.poll().subtract(s3.poll());
				}
			} else if (s2 != null) {
				for (int i = 0; i < sum.size(); i++) {
					total += sum.poll().subtract(s2.poll());
				}
			} else if (s1 != null) {
				for (int i = 0; i < sum.size(); i++) {
					total += sum.poll().subtract(s1.poll());
				}
			}
			if (total < -300) {
				return true;
			}
		}
		return false;
	}

	static void sendAlert() {
		System.out.println("Fall Detected!");
		alert.putPair("Status", "Fall");
		alert.putPair("Date", reading.date + "");
		try {
			encoder.sendMsg(alert);
		} catch (Exception e) {
		}
	}

	private static void ProcessMsg(KeyValueList kvList) throws Exception {

		String scope = kvList.getValue("Scope");
		if (!SCOPE.startsWith(scope)) {
			return;
		}

		String messageType = kvList.getValue("MessageType");
		if (!TYPES.contains(messageType)) {
			return;
		}

		String sender = kvList.getValue("Sender");

		String receiver = kvList.getValue("Receiver");

		String purpose = kvList.getValue("Purpose");

		switch (messageType) {
		case "Confirm":
			System.out.println("Connect to SISServer successful.");
			break;
		case "Setting":
			if (receiver.equals(NAME)) {
				System.out.println("Message from " + sender);
				System.out.println("Message type: " + messageType);
				System.out.println("Message Purpose: " + purpose);
				switch (purpose) {

				case "Activate":
					String rRate = kvList.getValue("RefreshRate");
					String sDate = kvList.getValue("StartDate");
					String eDate = kvList.getValue("EndDate");
					String maxx = kvList.getValue("Max");
					String minn = kvList.getValue("Min");

					if (rRate != null && !rRate.equals("")) {

						refreshRate = Integer.parseInt(rRate);

					}

					if (sDate != null && !sDate.equals("") && eDate != null
							&& !eDate.equals("")) {
						startDate.setTime(Long.parseLong(sDate));
						endDate.setTime(Long.parseLong(eDate));
					}

					if (maxx != null && !maxx.equals("") && minn != null
							&& !minn.equals("")) {
						max = Integer.parseInt(maxx);
						min = Integer.parseInt(minn);
					}

					try {
						timer.cancel();
						timer = new Timer();
					} catch (Exception e) {
						// TODO: handle exception
					}
					timer.schedule(new TimerTask() {

						@Override
						public void run() {
							// TODO Auto-generated method stub
							if (System.currentTimeMillis() - endDate.getTime() > 0) {
								cancel();
							} else {
								componentTask();
							}
						}
					}, startDate, refreshRate);
					System.out.println("Algorithm Activated");
					break;

				case "UpdateRecord":

					String frame = kvList.getValue("KinectData");
					String dat = kvList.getValue("Date");

					String[] rawVecs = frame.split("\\|");
					Queue<Vec> arr = new LinkedList<Vec>();
					for (int i = 0; i < rawVecs.length; i++) {
						arr.add(new Vec(rawVecs[i]));
					}
					queue.offer(arr);
					reading.coordinates = arr;
					reading.date = Long.parseLong(dat);
					++count;

					if (count > 5) {
						queue.poll();
						--count;
					}

					String factor = kvList.getValue("Status");
					if (factor != null && !factor.equals("")) {
						if (factor.equals("Fall")) {
							sendAlert();
						} else if (factor.equals("Normal") && fall()) {

						}
					}

					break;

				case "Kill":
					try {
						timer.cancel();
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.exit(0);
					break;
				// case "Activate":
				// try {
				// timer.cancel();
				// timer = new Timer();
				// } catch (Exception e) {
				// // TODO: handle exception
				// }
				// timer.schedule(new TimerTask() {
				//
				// @Override
				// public void run() {
				// // TODO Auto-generated method stub
				// if (System.currentTimeMillis() - endDate.getTime() > 0) {
				// cancel();
				// } else {
				// componentTask();
				// }
				// }
				// }, startDate, refreshRate);
				// System.out.println("Algorithm Activated");
				// break;
				case "Deactivate":
					try {
						timer.cancel();
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.out.println("Algorithm Deactivated");
					break;
				}
			}
			break;
		}
	}
}

class Vec {
	public int x;
	public int y;
	public int z;

	public Vec(String raw) {
		String[] raws = raw.split(" ");
		this.x = Integer.valueOf(raws[0]);
		this.y = Integer.valueOf(raws[1]);
		this.z = Integer.valueOf(raws[2]);
	}

	public Vec(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public int subtract(Vec v) {
		return x - v.x + y - v.y + z - v.z;
	}

	public void copy(Vec v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
	}

	@Override
	public boolean equals(Object obj) {
		// TODO Auto-generated method stub
		if (obj instanceof Vec) {
			Vec vec = (Vec) obj;
			return vec.x == this.x && vec.y == this.y && vec.z == this.z;
		} else {
			return false;
		}
	}

	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return "(" + x + ", " + y + ", " + z + ")";
	}
}

class KinectReading {
	Queue<Vec> coordinates = new LinkedList<Vec>();
	long date;

	public String getCoordinates() {
		StringBuilder builder = new StringBuilder();
		while (!coordinates.isEmpty()) {
			int i = 3;
			while (i > 0 && !coordinates.isEmpty()) {
				builder.append(coordinates.poll() + " ");
				--i;
			}
			builder.append("\n");
		}
		return builder.toString();
	}
}
