import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import java.text.SimpleDateFormat;
import java.util.Date;
import weka.core.Instance;

import java.net.*;
import java.io.*;

public class CreateBCIFilter {
    // socket for connection to SISServer
    static Socket universal;
    private static int port = 53217;
    // message writer
    static MsgEncoder encoder;
    // message reader
    static MsgDecoder decoder;

    // scope of this component
    private static final String SCOPE = "SIS.BCI";
    // name of this component
//    private static final String NAME = "BCIMonitor";//Liang
	private static final String NAME = "BCIFilter";//Liang

    // messages types that can be handled by this component
    // TODO: define your message here
    private static final List<String> TYPES= new ArrayList<String>(
			Arrays.asList(new String[] { "Setting", "Confirm","Reading","Alert" }));

    private static long time = System.currentTimeMillis();

    private static Timer timer = new Timer();

    // shared by all kinds of records that can be generated by this component
    private static KeyValueList record = new KeyValueList();
    // shared by all kinds of alerts that can be generated by this component
    private static KeyValueList alert = new KeyValueList();

    private static MonitorReading reading = new MonitorReading();
    
    private static ArrayList<double[]> alData = new ArrayList<double[]>();
    private static String data = "data";
    private static String model = "trained.model";
    private static ApplyModel am = null;
	private static int signalLength=100;//Duncan add [Feb 2017] 100 means 100 records
	private static int samplingRate=4;//Duncan add [Feb 2017] 10 means to get data every 10 second
	private static long startTime = System.currentTimeMillis();
    /*
     * Main program
     */
    public static void main(String[] args) {
    	try {
			am = new ApplyModel(data, model);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        while (true) {
            try {
                // try to establish a connection to SISServer
                universal = connect();

                // bind the message reader to inputstream of the socket
                decoder = new MsgDecoder(universal.getInputStream());
                // bind the message writer to outputstream of the socket
                encoder = new MsgEncoder(universal.getOutputStream());

                /*
                 * construct a Connect message to establish the connection
                 */
                KeyValueList conn = new KeyValueList();
                conn.putPair("Scope", SCOPE);
                conn.putPair("MessageType", "Connect");
                conn.putPair("Role", "Basic");
                conn.putPair("Name", NAME);
                encoder.sendMsg(conn);

                initRecord();

                // KeyValueList for inward messages, see KeyValueList for
                // details
                KeyValueList kvList;
				//startTime = System.currentTimeMillis();//Duncan Add[Feb 2017]
                while (true) {
                    // attempt to read and decode a message, see MsgDecoder for
                    // details
                    //System.out.println("************************begin");
					kvList = decoder.getMsg();
                    // process that message
					record = kvList;
					ProcessMsg(kvList);
					//System.out.println("************************end");
                }

            } catch (Exception e) {
                // if anything goes wrong, try to re-establish the connection
                try {
                    // wait for 1 second to retry
                    Thread.sleep(1000);
                } catch (InterruptedException e2) {
                }
                System.out.println("Try to reconnect");
                try {
                    universal = connect();
                } catch (IOException e1) {
                }
            }
        }
    }

    /*
     * used for connect(reconnect) to SISServer
     */
    static Socket connect() throws IOException {
        Socket socket = new Socket("127.0.0.1", port);
        return socket;
    }

    private static void initRecord() {
        record.putPair("Scope", SCOPE);
        record.putPair("MessageType", "Reading");
        record.putPair("Sender", NAME);

        // Receiver may be different for each message, so it doesn't make sense
        // to set here
        // record.putPair("Receiver", "");

        alert.putPair("Scope", SCOPE);
        alert.putPair("MessageType", "Alert");
        alert.putPair("Sender", NAME);
		alert.putPair("Purpose", "BCIAlert");//Liang
        // Receiver may be different for each message, so it doesn't make sense
        // to set here
        // alert.putPair("Receiver", "");
    }
    private static void componentTask(KeyValueList kvList) {
        try {

            // TODO: create your component task here
			filterBCI(kvList);
			time = System.currentTimeMillis();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void ProcessMsg(KeyValueList kvList) throws Exception {


		String scope = kvList.getValue("Scope");
		//System.out.println("scope--"+scope);//Liang
		//System.out.println("SCOPE--"+SCOPE);//Liang
        if (!SCOPE.startsWith(scope)) {
			//System.out.println("Exit");
            return;
        }

        String messageType = kvList.getValue("MessageType");
		//System.out.println("messageType--"+messageType);//Liang
		//System.out.println("TYPES--"+TYPES);//Liang
        if (!TYPES.contains(messageType)) {
		//	System.out.println("Exit");
            return;
        }

        String sender = kvList.getValue("Sender");
		reading.source_Sender=sender;//20160404
		//System.out.println("sender--"+sender);//Liang

        String receiver = kvList.getValue("Receiver");
		//System.out.println("receiver--"+receiver);//Liang

        String purpose = kvList.getValue("Purpose");
		//System.out.println("purpose--"+purpose);//Liang

		// TODO: create the logic according to different messge type
		//System.out.println(messageType);
        switch (messageType) {
            case "Confirm":
                System.out.println("Connect to SISServer successful.");
                break;
			case "Reading"://Liang	According BCISensor's send message
				long currentTime = System.currentTimeMillis();
				long diffTime = currentTime - time;
				//System.out.println(diffTime);
				
				String[] sChannels = new String[Integer.parseInt(kvList.getValue("channels"))];
                for (int i = 0; i < sChannels.length; i++) {
                	sChannels[i] = kvList.getValue("channels"+i);
                }
                reading.channels = new double[Integer.parseInt(kvList.getValue("channels"))];
                for (int i = 0; i < reading.channels.length; i++) {
                	if (sChannels[i] != null && !sChannels[i].equals("")) {
                        reading.channels[i] = Double.parseDouble(sChannels[i]);
                    }
                }
				if (alData.size() < 4) {
					alData.add(reading.channels);
				} 
				
				if (alData.size() == 4){
					analysis();
					alData = new ArrayList<double[]>();
				}
				
//				if (diffTime > 1000) {
				if((diffTime>(1000*samplingRate)) && ((currentTime - startTime) < (signalLength*1000))){
					componentTask(kvList);
				}
				
/*
                            timer.schedule(new TimerTask() {

                                @Override
                                public void run() {
                                    // Auto-generated method stub
                                    if (System.currentTimeMillis() - endDate.getTime() > 0) {
                                        cancel();
                                    } else {
                                        componentTask();
                                    }
                                }
                            }, startDate, refreshRate);
*/
                break;
			case "Setting":
                if (receiver.equals(NAME)) {	
                    System.out.println("Message from " + sender);
					System.out.println("Message Receiver: " + receiver);
					System.out.println("Message type: " + messageType);
                    System.out.println("Message Purpose: " + purpose);

                    switch (purpose) {
						case "SamplingRate"://Duncan add [Feb 2017]
							String _samplingRate = kvList.getValue("SamplingRate");
							samplingRate=Integer.parseInt(_samplingRate);
							break;
						case "SignalLength"://Duncan add [Feb 2017]
							String _signalLength = kvList.getValue("SignalLength");
							signalLength=Integer.parseInt(_signalLength);
							break;
						case "Activate":
                            // TODO: put your logic code here after the activation

							System.out.println("Algorithm Activated");
                            break;
                        // TODO: optionally, you can define your message here

                        case "Kill":
                            try {
                                timer.cancel();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            System.exit(0);
                            break;
                        // case "Activate":
                        // try {
                        // timer.cancel();
                        // timer = new Timer();
                        // } catch (Exception e) {
                        // // TODO: handle exception
                        // }
                        // timer.schedule(new TimerTask() {
                        //
                        // @Override
                        // public void run() {
                        // // TODO Auto-generated method stub
                        // if (System.currentTimeMillis() - endDate.getTime() > 0) {
                        // cancel();
                        // } else {
                        // componentTask();
                        // }
                        // }
                        // }, startDate, refreshRate);
                        // System.out.println("Algorithm Activated");
                        // break;
                        // case "Deactivate":
                        //     try {
                        //         timer.cancel();
                        //     } catch (Exception e) {
                        //         // TODO: handle exception
                        //     }
                        //     System.out.println("Algorithm Deactivated");
                        //     break;
                    }
                }
                break;
        }
    }
    
    private static void analysis () {
    	try{
    		Instance instance = am.createInstance(alData);
    		
    		//System.out.println(am.apply(instance));
    	} catch (Exception e) {
    		System.out.println("Error in analysis");
    	}
    	
    }
	
	private static void filterBCI(KeyValueList kvList) {
        try {
//			if(reading.source_Sender.equals("BCIWebGUI")){
//                alert.putPair("Receiver", "BCIUploader");
//                alert.putPair("Purpose", "analysis");
//                alert.putPair("MessageType", "Reading");
//                System.out.println(alert.toString());
//                //alert.putPair("WebGUI", "True");
//            }
//			alert.putPair("Sender", NAME);
//			alert.putPair("uid", reading.uid + "");
//			alert.putPair("tongue", reading.VT + "");
//			alert.putPair("fatigue", reading.VF + "");
//			alert.putPair("weakBreadth", reading.VW + "");
//			alert.putPair("pulse", reading.VP + "");
//			alert.putPair("sweaty", reading.VS + "");
//			alert.putPair("BCITotal", reading.V + "");
//			alert.putPair("datetime", reading.mDate + "");//			alert.putPair("Date", System.currentTimeMillis() + "");
//			alert.putPair("originator", reading.Originator + "");		
        	System.out.println("BCIFilter:filterBCI");
/*			String[] sChannels = new String[Integer.parseInt(record.getValue("channels"))];
			for (int i = 0; i < sChannels.length; i++){
                sChannels[i] = kvList.getValue("channels"+i);
            }
			
            reading.channels = new double[Integer.parseInt(kvList.getValue("channels"))];
            for(int i = 0; i < reading.channels.length; i++) {
                if (i%samplingRate==0 && sChannels[i] != null && !sChannels[i].equals("")){
                    reading.channels[i] = Double.parseDouble(sChannels[i]);
                }
            }*/
			
//        	record.putPair("Receiver", "BCIUploader");
			record.putPair("Receiver", "Uploader");//for android uploader
        	record.putPair("Sender", NAME);
        	record.putPair("Purpose", "upload");
			encoder.sendMsg(record);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

class MonitorReading {
    // TODO: define your reading input here
	int uid;
	double[] channels;
	String source_Sender;		//sender
}