import java.io.IOException;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

public class CreateSPO2 {
	// socket for connection to SISServer
	static Socket universal;
	private static int port = 53217;
	// message writer
	static MsgEncoder encoder;
	// message reader
	static MsgDecoder decoder;

	// scope of this component
	private static final String SCOPE = "SIS.Ren";
	// name of this component
    private static final String NAME = "SPO2";
	// messages types that can be handled by this component
	private static final List<String> TYPES = new ArrayList<String>(
			Arrays.asList(new String[] { "Setting", "Confirm" }));

	private static int refreshRate = 500, max, min = 90;
	private static Date startDate = new Date(), endDate = new Date();

	private static Timer timer = new Timer();

	// shared by all kinds of records that can be generated by this component
	private static KeyValueList record = new KeyValueList();
	// shared by all kinds of alerts that can be generated by this component
	private static KeyValueList alert = new KeyValueList();

	private static SPO2Reading reading = new SPO2Reading();

	/*
	 * Main program
	 */
	public static void main(String[] args) {
		while (true) {
			try {
				// try to establish a connection to SISServer
				universal = connect();

				// bind the message reader to inputstream of the socket
				decoder = new MsgDecoder(universal.getInputStream());
				// bind the message writer to outputstream of the socket
				encoder = new MsgEncoder(universal.getOutputStream());

				/*
				 * construct a Connect message to establish the connection
				 */
				KeyValueList conn = new KeyValueList();
				conn.putPair("Scope", SCOPE);
				conn.putPair("MessageType", "Connect");
				conn.putPair("Role", "Basic");
				conn.putPair("Name", NAME);
				encoder.sendMsg(conn);

				initRecord();

				// KeyValueList for inward messages, see KeyValueList for
				// details
				KeyValueList kvList;

				while (true) {
					// attempt to read and decode a message, see MsgDecoder for
					// details
					kvList = decoder.getMsg();

					// process that message
					ProcessMsg(kvList);
				}

			} catch (Exception e) {
				// if anything goes wrong, try to re-establish the connection
				try {
					// wait for 1 second to retry
					Thread.sleep(1000);
				} catch (InterruptedException e2) {
				}
				System.out.println("Try to reconnect");
				try {
					universal = connect();
				} catch (IOException e1) {
				}
			}
		}
	}

	/*
	 * used for connect(reconnect) to SISServer
	 */
	static Socket connect() throws IOException {
		Socket socket = new Socket("127.0.0.1", port);
		return socket;
	}

	private static void initRecord() {
		record.putPair("Scope", SCOPE);
		record.putPair("MessageType", "Reading");
		record.putPair("Sender", NAME);

		// Receiver may be different for each message, so it doesn't make sense
		// to set here
		// record.putPair("Receiver", "");

		alert.putPair("Scope", SCOPE);
		alert.putPair("MessageType", "Alert");
		alert.putPair("Sender", NAME);

		// Receiver may be different for each message, so it doesn't make sense
		// to set here
		// alert.putPair("Receiver", "");
	}

	private static void componentTask() {
		try {

			record.putPair(NAME, reading.spo2 + "");
			record.putPair("Date", reading.date + "");
			encoder.sendMsg(record);

			alert.putPair(NAME, reading.spo2 + "");
			alert.putPair("Date", reading.date + "");
			// critical < 80%, worth checking < 90%
			if (reading.spo2 < min) {
				encoder.sendMsg(alert);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void ProcessMsg(KeyValueList kvList) throws Exception {

		String scope = kvList.getValue("Scope");
		if (!SCOPE.startsWith(scope)) {
			return;
		}

		String messageType = kvList.getValue("MessageType");
		if (!TYPES.contains(messageType)) {
			return;
		}

		String sender = kvList.getValue("Sender");

		String receiver = kvList.getValue("Receiver");

		String purpose = kvList.getValue("Purpose");

		switch (messageType) {
		case "Confirm":
			System.out.println("Connect to SISServer successful.");
			break;
		case "Setting":
			if (receiver.equals(NAME)) {
				System.out.println("Message from " + sender);
				System.out.println("Message type: " + messageType);
				System.out.println("Message Purpose: " + purpose);
				switch (purpose) {

				case "Activate":
					String rRate = kvList.getValue("RefreshRate");
					String sDate = kvList.getValue("StartDate");
					String eDate = kvList.getValue("EndDate");
					String maxx = kvList.getValue("Max");
					String minn = kvList.getValue("Min");

					if (rRate != null && !rRate.equals("")) {

						refreshRate = Integer.parseInt(rRate);

					}

					if (sDate != null && !sDate.equals("") && eDate != null
							&& !eDate.equals("")) {
						startDate.setTime(Long.parseLong(sDate));
						endDate.setTime(Long.parseLong(eDate));
					}

					if (maxx != null && !maxx.equals("") && minn != null
							&& !minn.equals("")) {
						max = Integer.parseInt(maxx);
						min = Integer.parseInt(minn);
					}

					try {
						timer.cancel();
						timer = new Timer();
					} catch (Exception e) {
						// TODO: handle exception
					}
					timer.schedule(new TimerTask() {

						@Override
						public void run() {
							// TODO Auto-generated method stub
							if (System.currentTimeMillis() - endDate.getTime() > 0) {
								cancel();
							} else {
								componentTask();
							}
						}
					}, startDate, refreshRate);
					System.out.println("Algorithm Activated");
					break;

				case "UpdateRecord":
					String spo = kvList.getValue(NAME);
					String dat = kvList.getValue("Date");

					if (spo != null && !spo.equals("")) {
						reading.spo2 = Integer.parseInt(spo);
					}
					if (dat != null && !dat.equals("")) {
						reading.date = Long.parseLong(dat);
					}

					break;

				case "Kill":
					try {
						timer.cancel();
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.exit(0);
					break;
				// case "Activate":
				// try {
				// timer.cancel();
				// timer = new Timer();
				// } catch (Exception e) {
				// // TODO: handle exception
				// }
				// timer.schedule(new TimerTask() {
				//
				// @Override
				// public void run() {
				// // TODO Auto-generated method stub
				// if (System.currentTimeMillis() - endDate.getTime() > 0) {
				// cancel();
				// } else {
				// componentTask();
				// }
				// }
				// }, startDate, refreshRate);
				// System.out.println("Algorithm Activated");
				// break;
				case "Deactivate":
					try {
						timer.cancel();
					} catch (Exception e) {
						// TODO: handle exception
					}
					System.out.println("Algorithm Deactivated");
					break;
				}
			}
			break;
		}
	}
}

class SPO2Reading {
	int spo2;
	long date;
}
